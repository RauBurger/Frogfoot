/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : USB_LDD.c
**     Project     : Frogfoot
**     Processor   : MK60FN1M0VLQ12
**     Component   : USB_LDD
**     Version     : Component 01.307, Driver 01.02, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-01-24, 15:32, # CodeGen: 0
**     Abstract    :
**         This component implements an low level USB API.
**     Settings    :
**          Component name                                 : USB_LDD
**          USB module (SIE)                               : USBHS
**          Input clock frequency [MHz]                    : 60 MHz
**          Interrupt service/event                        : Enabled
**            Interrupt                                    : INT_USBHS
**            Interrupt priority                           : maximal priority
**          Mode                                           : DEVICE
**            Transceiver type                             : External (ULPI)
**              ULPI interface                             : USBHS_ULPI
**              UTMI+ level                                : UTMI+ 3
**              USB revision                               : USB 2.0
**              Device data rate                           : Dual speed
**              Pin/signal setting                         : 
**                Clock pin                                : Clock input
**                  Pin                                    : ADC3_SE6a/PTA6/ULPI_CLK/FTM0_CH3/I2S1_RXD0/CLKOUTb/TRACE_CLKOUT
**                  Pin signal                             : 
**                  Clock frequency [MHz]                  : 60
**                Direction pin                            : 
**                  Pin                                    : ADC0_SE10/PTA7/ULPI_DIR/FTM0_CH4/I2S1_RX_BCLK/TRACE_D3
**                  Pin signal                             : 
**                Next data pin                            : 
**                  Pin                                    : ADC0_SE11/PTA8/ULPI_NXT/FTM1_CH0/I2S1_RX_FS/FTM1_QD_PHA/TRACE_D2
**                  Pin signal                             : 
**                Stop pin                                 : 
**                  Pin                                    : ADC3_SE5a/PTA9/ULPI_STP/FTM1_CH1/MII0_RXD3/FTM1_QD_PHB/TRACE_D1
**                  Pin signal                             : 
**                Data pins                                : 
**                  Data 0 pin                             : 
**                    Pin                                  : ADC3_SE4a/PTA10/ULPI_DATA0/FTM2_CH0/MII0_RXD2/FTM2_QD_PHA/TRACE_D0
**                    Pin signal                           : 
**                  Data 1 pin                             : 
**                    Pin                                  : ADC3_SE15/PTA11/ULPI_DATA1/FTM2_CH1/MII0_RXCLK/FTM2_QD_PHB
**                    Pin signal                           : 
**                  Data 2 pin                             : 
**                    Pin                                  : CMP3_IN4/PTA24/ULPI_DATA2/MII0_TXD2/FBa_A29
**                    Pin signal                           : 
**                  Data 3 pin                             : 
**                    Pin                                  : CMP3_IN5/PTA25/ULPI_DATA3/MII0_TXCLK/FBa_A28
**                    Pin signal                           : 
**                  Data 4 pin                             : 
**                    Pin                                  : ADC2_SE15/PTA26/ULPI_DATA4/MII0_TXD3/FBa_A27
**                    Pin signal                           : 
**                  Data 5 pin                             : 
**                    Pin                                  : ADC2_SE14/PTA27/ULPI_DATA5/MII0_CRS/FBa_A26
**                    Pin signal                           : 
**                  Data 6 pin                             : 
**                    Pin                                  : ADC2_SE13/PTA28/ULPI_DATA6/MII0_TXER/FBa_A25
**                    Pin signal                           : 
**                  Data 7 pin                             : 
**                    Pin                                  : ADC2_SE12/PTA29/ULPI_DATA7/MII0_COL/FBa_A24
**                    Pin signal                           : 
**            Device mode setting                          : 
**              Tx burst length                            : 1
**              Rx burst length                            : 5
**              EP list                                    : 16
**                EP 0                                     : Enabled
**                  Control transfer                       : Enabled
**                    Maximum packet size                  : 32
**                    Max. queue size                      : 1
**                  Bulk OUT transfer                      : Disabled
**                  Bulk IN transfer                       : Disabled
**                  Interrupt OUT transfer                 : Disabled
**                  Interrupt IN transfer                  : Disabled
**                  Isochronous OUT  transfer              : Disabled
**                  Isochronous IN  transfer               : Disabled
**                EP 1                                     : Enabled
**                  Control transfer                       : Disabled
**                  Bulk OUT transfer                      : Enabled
**                    Max. packet size                     : 64
**                    Max. queue size                      : 1
**                  Bulk IN transfer                       : Enabled
**                    Max. packet size                     : 64
**                    Max. queue size                      : 1
**                  Interrupt OUT transfer                 : Disabled
**                  Interrupt IN transfer                  : Disabled
**                  Isochronous OUT  transfer              : Disabled
**                  Isochronous IN  transfer               : Disabled
**                EP 2                                     : Disabled
**                EP 3                                     : Disabled
**                EP 4                                     : Disabled
**                EP 5                                     : Disabled
**                EP 6                                     : Disabled
**                EP 7                                     : Disabled
**                EP 8                                     : Disabled
**                EP 9                                     : Disabled
**                EP 10                                    : Disabled
**                EP 11                                    : Disabled
**                EP 12                                    : Disabled
**                EP 13                                    : Disabled
**                EP 14                                    : Disabled
**                EP 15                                    : Disabled
**            Initialization                               : 
**              Enabled in init. code                      : no
**              Auto initialization                        : no
**              Event mask                                 : 
**                OnDeviceReset                            : Disabled
**                OnDeviceSpeedDetect                      : Enabled
**                OnDeviceSuspend                          : Disabled
**                OnDeviceResume                           : Disabled
**                OnDeviceSetupPacket                      : Enabled
**                OnDeviceSof                              : Disabled
**                OnDeviceError                            : Disabled
**                OnDevice1msTimer                         : Disabled
**                OnSignalChange                           : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init                  - LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr);
**         Enable                - LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable               - LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr);
**         DeviceGetUsbStatus    - LDD_TError USB_LDD_DeviceGetUsbStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceSetUsbStatus    - LDD_TError USB_LDD_DeviceSetUsbStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceSetAddress      - void USB_LDD_DeviceSetAddress(LDD_TDeviceData *DeviceDataPtr, uint8_t Address);
**         DeviceInitEndpoint    - LDD_TError USB_LDD_DeviceInitEndpoint(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceDeinitEndpoint  - LDD_TError USB_LDD_DeviceDeinitEndpoint(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceStallEndpoint   - void USB_LDD_DeviceStallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceUnstallEndpoint - void USB_LDD_DeviceUnstallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceReadSetupData   - void USB_LDD_DeviceReadSetupData(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceSendData        - LDD_TError USB_LDD_DeviceSendData(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceRecvData        - LDD_TError USB_LDD_DeviceRecvData(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceCancelTransfer  - LDD_TError USB_LDD_DeviceCancelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file USB_LDD.c
** @version 01.02
** @brief
**         This component implements an low level USB API.
*/         
/*!
**  @addtogroup USB_LDD_module USB_LDD module documentation
**  @{
*/         

/* MODULE USB_LDD. */

#include "Events.h"
#include "USB_LDD.h"
/* {Default RTOS Adapter} No RTOS includes */
/*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */

#include "USBHS_PDD.h"

#ifdef __cplusplus
extern "C" {
#endif 

#define USB_LDD_AVAILABLE_IN_SIGNALS_MASK ((LDD_TPinMask)(0x00U))

#define USB_LDD_IN_SIGNALS_INIT_VALUE ((LDD_TPinMask)(0x00U))


#define USB_LDD_TD_ACTIVE_MASK                    0x80U
#define USB_LDD_TD_HALTED_MASK                    0x40U
#define USB_LDD_TD_BUFFER_ERROR_MASK              0x20U
#define USB_LDD_TD_TRANSACTION_ERROR_MASK         0x08U
#define USB_LDD_TD_ERROR_MASK                     (USB_LDD_TD_TRANSACTION_ERROR_MASK | USB_LDD_TD_BUFFER_ERROR_MASK | USB_LDD_TD_HALTED_MASK)
#define USB_LDD_TD_IOC_MASK                       0x8000U

#define MAX_EP_IDX                                0x03u
#define MAX_BD_IDX                                0x07u

#define USB_LDD_DEVICE_WAKE_UP_READY_TIME         0x06 /* Number of ms the bus must be idle to force wake-up signaling */
#define USB_LDD_DEVICE_SUSPEND_DETECTION_TIME     0x03 /* Number of milliseconds from last EOP to detect IDLE */
#define USB_LDD_DEVICE_RESUME_DURATION            0x05 /* Number of milliseconds from last EOP to detect SUSPEND */
#define USB_LDD_DEVICE_RESUME_DETECTED            0x07 /* Constants specify that non IDLE state during suspend has been detected */
#define USB_LDD_A_WAIT_VRISE_TIME_OUT_MS          0x64
#define USB_LDD_A_WAIT_BCON_SHORT_DEBOUCE_MS      0x01
#define USB_LDD_A_WAIT_BCON_LONG_DEBOUCE_MS       0x64
#define USB_LDD_A_WAIT_BCON_TIME_OUT_MS           0x044C
#define USB_LDD_A_IDLE_BDIS_TIME_OUT_MS           0xC8
#define USB_LDD_B_ASE0_TIME_OUT_MS                0x9B
#define USB_LDD_B_SE0_SRP_TIME_OUT_MS             0x03
#define USB_LDD_B_DATA_PLS_TIME_OUT_MS            0x07

/* OTG input variables */
#define USB_LDD_OTG_TIMEOUT                       0x80000000u
#define USB_LDD_OTG_1MS_TIMEOUT                   0x40000000u
#define USB_LDD_OTG_A_BUS_RESUME                  0x20000000u
#define USB_LDD_OTG_A_BUS_SUSPEND                 0x10000000u
#define USB_LDD_OTG_A_CONN                        0x08000000u
#define USB_LDD_OTG_A_SESSION_VALID               0x08u
#define USB_LDD_OTG_A_SRP_DET                     0x04000000u
#define USB_LDD_OTG_A_VBUS_VALID                  0x01u
#define USB_LDD_OTG_B_BUS_RESUME                  0x02000000u
#define USB_LDD_OTG_B_BUS_SUSPEND                 0x01000000u
#define USB_LDD_OTG_B_CONN                        0x00800000u
#define USB_LDD_OTG_B_SE0_SRP                     0x00400000u
#define USB_LDD_OTG_B_SESSION_VALID               0x08u
#define USB_LDD_OTG_B_SESSION_END                 0x04u
#define USB_LDD_OTG_ID                            0x80u

#define USB_LDD_OTG_VBUS_VALID                    0x01u
#define USB_LDD_OTG_SESSION_VALID                 0x08u

/* Informative variables */
#define USB_LDD_OTG_A_BUS_DROP                    0x00200000u
#define USB_LDD_OTG_A_BUS_REQ                     0x00100000u
#define USB_LDD_OTG_A_CLR_ERR                     0x00080000u
#define USB_LDD_OTG_A_SUSPEND_REQ                 0x00040000u
#define USB_LDD_OTG_B_BUS_REQ                     0x00020000u

/* Internal variables */
#define USB_LDD_TIMEOUT                           0x02u
#define USB_LDD_1MS_TIMEOUT                       0x40u
#define USB_LDD_OTG_A_SET_B_HNP_EN                0x00010000u
#define USB_LDD_OTG_B_SRP_DONE                    0x8000u
#define USB_LDD_OTG_B_HNP_EN                      0x4000u
#define USB_LDD_OTG_NOT_SE0                       0x2000u

#define USB_LDD_DEVICE_VBUS_DETECT                0x04u
#define USB_LDD_HOST_VBUS_OVERCURRENT             0x04u

#define USB_LDD_EnableTimer() USBHS_PDD_Enable1msInterrupt(USBHS_BASE_PTR)

/* Capabilities dword definition of the device queue head structure -------- */
/*lint -save  -e46 Disable MISRA rule (6.4) checking. */
typedef union {
  uint32_t                         dwCapabilities;
  struct {
    uint32_t                       Reserved_1       :15;
    uint32_t                       Ios              :1;
    uint32_t                       MaxPacketSize    :11;
    uint32_t                       Reserved_0       :2;
    uint32_t                       Zlt              :1;
    uint32_t                       Mult             :2;
  } Bits;
} USB_LDD_TCapabilities;

/* Token dword definition of the transfer descriptor structure ------------- */
typedef union {
  uint32_t                         dwToken;
  struct {
    uint32_t                       Reserved_0_2     :3;
    uint32_t                       TransactionError :1;
    uint32_t                       Reserved_4       :1;
    uint32_t                       DataBufferError  :1;
    uint32_t                       Halted           :1;
    uint32_t                       Active           :1;
    uint32_t                       Reserved_8_9     :2;
    uint32_t                       MultO            :2;
    uint32_t                       Reserved_12_14   :3;
    uint32_t                       Ioc              :1;
    uint32_t                       TotalBytes       :15;
    uint32_t                       Reserved_31      :1;
  } Bits;
} USB_LDD_TToken;
/*lint -restore Enable MISRA rule (6.4) checking. */

/* Transfer descriptor structure ------------------------------------------- */
typedef struct _TD {
  struct _TD*                      NextTDPtr;
  USB_LDD_TToken                   Token;
  uint32_t                         Page0;
  uint32_t                         Page1;
  uint32_t                         Page2;
  uint32_t                         Page3;
  uint32_t                         Page4;
  LDD_USB_Device_TTD              *UserTDPtr;
} USB_LDD_TTD;

/* Endpoint queue head structure ------------------------------------------- */
typedef struct EpQH_struct {
  USB_LDD_TCapabilities            Capabilities;
  USB_LDD_TTD                     *CurrentTDPtr;
  USB_LDD_TTD                      TD;
  LDD_USB_TSDP                     SDP;
  USB_LDD_TTD                     *TDQueuePtr;   /* Address of the TD queue */
  USB_LDD_TTD                     *TDQueueHeadPtr; /* Address of the first TD */
  USB_LDD_TTD                     *TDQueueTailPtr; /* Address of the last TD */
  uint32_t                         Reserved0;
} USB_LDD_TQH;


typedef enum {
  USB_LDD_EP_NOT_AVAILABLE                        = 0x00U, /* Endpoint is not supported by the driver */
  USB_LDD_EP_NOT_CONFIGURED                       = 0x01U, /* Endpoint is not enabled by the Host */
  USB_LDD_EP_STALLED                              = 0x02U, /* Endpoint is stalled */
  USB_LDD_EP_IDLE                                 = 0x04U, /* Endpoint is idle */
  USB_LDD_EP_BUSY                                 = 0x08U /* Endpoint is busy */
} USB_LDD_TePState;

typedef enum {
  USB_LDD_CONTROL_NO_DATA,
  USB_LDD_CONTROL_NO_DATA_HSK,
  USB_LDD_CONTROL_READ_DATA,
  USB_LDD_CONTROL_READ_HSK,
  USB_LDD_CONTROL_WRITE_DATA,
  USB_LDD_CONTROL_WRITE_HSK
} USB_LDD_TCtrlTransferStage;

/* Endpoint private data structure */
typedef struct USB_LDD_TEpData_Struct {
  USB_LDD_TePState                 EpState;      /* EP state */
  uint8_t                          EpNumber;     /* EP number */
  LDD_USB_TTransferType            TransferType; /* EP Transfer type */
  uint16_t                         MaxPacketSize; /* EP max. packet size */
  union {
    struct {
      uint16_t                     ReqDataSize;
      USB_LDD_TCtrlTransferStage   Stage;
    } Ctrl;
  } TT;
  uint32_t                         EpMask;       /* EP mask */
  void                            *EpCtrlRegAddr; /* EP control register address */
} USB_LDD_TEpData;


/* Device data structure */
typedef struct USB_LDD_TDeviceData_Struct {
  USB_LDD_TQH                      EpQH[0x04];   /* Endpoint device queue haeds array. Each item has 64 byte */
  USB_LDD_TTD                      EP_0_OUT_dTD_Queue[0x01U];
  USB_LDD_TTD                      EP_0_IN_dTD_Queue[0x01U];
  USB_LDD_TTD                      EP_1_OUT_dTD_Queue[0x01U];
  USB_LDD_TTD                      EP_1_IN_dTD_Queue[0x01U];
  USB_LDD_TEpData                  EpData[0x04]; /* EP data array */
  LDD_USB_Device_TState            DeviceState;  /* Internal device engine state */
  LDD_USB_Device_TState            LastDeviceState; /* State before entering suspend mode */
  LDD_TUserData                   *UserDeviceDataPtr; /* Device mode user device data structure */
  bool                             ISR;          /* TRUE if ISR is in progress */
  bool                             EnUser;       /* Enable/Disable device state variable */
  uint32_t                         InSignalsState; /* Input signals state variable */
} USB_LDD_TDeviceData, *USB_LDD_TDeviceDataPtr;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static USB_LDD_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC __attribute__ ((aligned (2048)));
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static USB_LDD_TDeviceDataPtr INT_USBHS__DEFAULT_RTOS_ISRPARAM;

/* Control endpoint macros */
#define USB_LDD_EnableCtrlEp(CtrlRegAddr)                      (*(uint32_t *)(void *)((uint32_t)CtrlRegAddr & (uint32_t)0xFFFFFFFDU)  = 0x00800080U)
#define USB_LDD_DisableCtrlEp(CtrlRegAddr)                     (*(uint32_t *)(void *)((uint32_t)CtrlRegAddr & (uint32_t)0xFFFFFFFDU)  = 0x00U)
#define USB_LDD_HwStallCtrlEp(CtrlRegAddr)                     (*(uint32_t *)(void *)((uint32_t)CtrlRegAddr & (uint32_t)0xFFFFFFFDU)  = 0x00810081U)
#define USB_LDD_HwUnstallCtrlEp(CtrlRegAddr)                   (*(uint32_t *)(void *)(CtrlRegAddr)  = 0x00C000C0U)
/* Bulk/Interrupt/Isochronous endpoints macros */
#define USB_LDD_EnableBulkIntIsoEp(CtrlRegAddr, TransferType)  (*(uint16_t *)(void *)(CtrlRegAddr)  = (uint16_t)(0xC0U | ((uint32_t)(TransferType)<<2)))
#define USB_LDD_DisableBulkIntIsoEp(CtrlRegAddr)               (*(uint16_t *)(void *)(CtrlRegAddr)  = (uint16_t)(0x00U))
#define USB_LDD_HwStallBulkIntIsoEp(CtrlRegAddr)               (*(uint16_t *)(void *)(CtrlRegAddr) |= (uint16_t)0x01U)
#define USB_LDD_HwUnstallBulkIntIsoEp(CtrlRegAddr)             (*(uint16_t *)(void *)(CtrlRegAddr)  = (uint16_t)((uint16_t)((*(uint16_t *)(void *)(CtrlRegAddr)) & (uint16_t)0xFEU) | (uint16_t)0x40U))

/*
** ===================================================================
**     Method      :  USB_LDD_UsbLock (component USB_LDD)
**
**     Description :
**         USB lock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbLock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_UsbUnlock (component USB_LDD)
**
**     Description :
**         USB unlock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbUnlock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceCompleteTD (component USB_LDD)
**
**     Description :
**         Complete transfer and calls user provided callback
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceCompleteTD(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TTD *TDPtr)
{
  LDD_USB_Device_TTD              *UserTDPtr;

  UserTDPtr = TDPtr->UserTDPtr;                            /* Get extended transfer parameters address */
  TDPtr->NextTDPtr = (USB_LDD_TTD *)((uint32_t)TDPtr->NextTDPtr | 0x01U); /* Mark TD as terminate */
  if (UserTDPtr != NULL) {                                 /* Extended transfer parameters exists? */
    if (TDPtr->Token.dwToken & (USB_LDD_TD_ACTIVE_MASK  | USB_LDD_TD_ERROR_MASK)) { /* Transfer active or complete with error? */
      if (TDPtr->Token.dwToken & USB_LDD_TD_ACTIVE_MASK) { /* Transfer active? */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_ERROR_CANCELLED; /* Return transfer cancelled status */
      } else if (TDPtr->Token.dwToken & USB_LDD_TD_HALTED_MASK) { /* Halted? */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_ERROR_STALLED; /* Return stall status */
      } else if (TDPtr->Token.dwToken & USB_LDD_TD_BUFFER_ERROR_MASK) { /* Buffer underrun or overrun? */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_ERROR_DMA; /* Return buffer error status */
      } else {                                             /* Transaction error? */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_ERROR; /* Return transfer error status */
      }
    } else {
      UserTDPtr->TransferState = LDD_USB_TRANSFER_DONE;    /* Transfer done without errors */
    }
    UserTDPtr->TransmittedDataSize = UserTDPtr->Head.BufferSize - TDPtr->Token.Bits.TotalBytes; /* Get transmitted data size */
    TDPtr->Token.dwToken = 0U;                             /* Mark TD as not active */
    TDPtr->UserTDPtr = NULL;                               /* Discard link to the user data */
    if (UserTDPtr->CallbackFnPtr != NULL) {                /* Callback required? */
      UserTDPtr->CallbackFnPtr(DevDataPtr->UserDeviceDataPtr, UserTDPtr); /* Call notification function */
    }
  } else {
    TDPtr->Token.dwToken = 0U;                             /* Mark TD as not active */
  }
}
/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueInsert (component USB_LDD)
**
**     Description :
**         Inserts Transfer descriptor to the TD queue
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceQueueInsert(USB_LDD_TDeviceData *DevDataPtr, LDD_USB_Device_TTD *UserTDPtr, uint32_t EpDir)
{
  USB_LDD_TQH                     *EpQHPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TTD                     *NewTDPtr;
  USB_LDD_TTD                     *TailTDPtr;
  uint32_t                         EpIdx;
  uint8_t                         *BufferPtr;
  uint32_t                         BufferSize;
  uint32_t                         x;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpIdx = ((uint32_t)UserTDPtr->Head.EpNum << 0x01u);
  if (EpDir != LDD_USB_DIR_OUT) {                          /* Get EpIdx */
    EpIdx++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpIdx > MAX_EP_IDX) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  EpDataPtr = &DevDataPtr->EpData[EpIdx];
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState < USB_LDD_EP_IDLE) {              /* Is EP ready for transmittion? */
    if (((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) != 0x00U) { /* No, is EP stalled? */
      Res = ERR_FAILED;                                    /* EP is stalled, return with error */
    } else {
      Res = ERR_NOTAVAIL;                                  /* EP is not enabled,  return with error */
    }
  } else {
    /* Try to find empty TD */
    EpQHPtr     = &DevDataPtr->EpQH[EpIdx];                /* Get address of the Ep queue head */
    NewTDPtr = (USB_LDD_TTD *)((uint32_t)EpQHPtr->TDQueueTailPtr->NextTDPtr & 0xFFFFFFFEU); /* Get next TD */
    if (NewTDPtr->Token.dwToken & USB_LDD_TD_ACTIVE_MASK) { /* Is TD active? */
      Res = ERR_QFULL;                                     /* Yes, queue is full, return error */
    } else {
      if (NewTDPtr->Token.dwToken & USB_LDD_TD_ERROR_MASK) { /* Is TD completed with error */
        USB_LDD_DeviceCompleteTD(DevDataPtr, NewTDPtr);    /* Yes, call calback if required */
      }
      NewTDPtr->NextTDPtr = (USB_LDD_TTD *)((uint32_t)NewTDPtr->NextTDPtr | 1U); /* Set Terminate bit */
      BufferPtr = UserTDPtr->Head.BufferPtr;
      NewTDPtr->Page0 = (uint32_t)BufferPtr;
      BufferPtr = (uint8_t*)(((uint32_t)BufferPtr + 0x1000U) & 0xFFFFF000U);
      NewTDPtr->Page1 = (uint32_t)BufferPtr;
      BufferPtr += 0x1000U;
      NewTDPtr->Page2 = (uint32_t)BufferPtr;
      BufferPtr += 0x1000U;
      NewTDPtr->Page3 = (uint32_t)BufferPtr;
      BufferPtr += 0x1000U;
      NewTDPtr->Page4 = (uint32_t)BufferPtr;
      BufferSize = UserTDPtr->Head.BufferSize;
      if (EpDataPtr->TransferType == LDD_USB_CONTROL) {    /* Control transfer? */
        switch (EpDataPtr->TT.Ctrl.Stage) {
          case USB_LDD_CONTROL_READ_HSK:
            /* Control read - handshake stage (Rx) */
            break;
          case USB_LDD_CONTROL_WRITE_DATA:
            /* Control write - data stage (Rx) */
            if (BufferSize >= EpDataPtr->TT.Ctrl.ReqDataSize) { /* Greater buffer then the data sent by the Host? */
              BufferSize = EpDataPtr->TT.Ctrl.ReqDataSize; /* Yes, receive all data send by the host */
            }
            break;
          case USB_LDD_CONTROL_READ_DATA:
            /* Control read - data stage (Rx) */
            if (BufferSize >= EpDataPtr->TT.Ctrl.ReqDataSize) { /* More data then the Host expects? */
              BufferSize = EpDataPtr->TT.Ctrl.ReqDataSize; /* Yes, send only requested data size */
            } else {
            }
            break;
          case USB_LDD_CONTROL_WRITE_HSK:
          case USB_LDD_CONTROL_NO_DATA_HSK:
            /* Control write/no-data - handshake stage (Tx) */
            break;
          default:
            break;
        }
      } else {                                             /* Non-control transfer */
        ;
      }
      NewTDPtr->Token.dwToken = ((BufferSize<<0x10) | USB_LDD_TD_ACTIVE_MASK); /* Set transfer size and active bit */
      if ((UserTDPtr->Head.Flags & (uint32_t)LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM) != 0x00U) { /* Additional transfer params? */
        /* If additional transfer params are requested the user TD must not be */
        /* released until the callback is called or the transfer state        */
        /* is LDD_USB_TRANSFER_PENDING */
        NewTDPtr->UserTDPtr = UserTDPtr;                   /* Remember transfer descriptor address? */
        UserTDPtr->TransmittedDataSize = 0x00U;            /* No data transmitted yet */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_PENDING; /* Transfer is pending */
        NewTDPtr->Token.dwToken |= USB_LDD_TD_IOC_MASK;    /* Set interrupt on complete bit */
      } else {
        NewTDPtr->UserTDPtr = NULL;
      }

      TailTDPtr = EpQHPtr->TDQueueTailPtr;
      if (NewTDPtr == TailTDPtr) {                         /* Empty queue? */
        EpQHPtr->TD.NextTDPtr = NewTDPtr;
        EpQHPtr->TD.Token.dwToken = 0U;
        USBHS_PDD_PrimeEndpoint(USBHS_BASE_PTR, EpDataPtr->EpMask);
        Res = ERR_OK;
      } else {
        if (NewTDPtr != TailTDPtr) {
          TailTDPtr->NextTDPtr = (USB_LDD_TTD *)((uint32_t)TailTDPtr->NextTDPtr & ~(uint32_t)0x01); /* Clear terminate bit in the last inserted TD */
        }
        EpQHPtr->TDQueueTailPtr = NewTDPtr; /* Actualize last TD pointer */
        EpDataPtr = &DevDataPtr->EpData[EpIdx];            /* Get address of the Ep data */
        if (!USBHS_PDD_GetPrimeEndpointPendingFlag(USBHS_BASE_PTR, EpDataPtr->EpMask)) { /* If prime bit set, DONE */
          do {
            USBHS_PDD_SetSetupTripwire(USBHS_BASE_PTR);
            x = USBHS_PDD_GetEndpointStatusFlag(USBHS_BASE_PTR, EpDataPtr->EpMask);
          } while (!USBHS_PDD_GetSetupTripwire(USBHS_BASE_PTR));
          USBHS_PDD_ClrSetupTripwire(USBHS_BASE_PTR);
          if (x == 0x00U) {
            EpQHPtr->TD.NextTDPtr = NewTDPtr;
            EpQHPtr->TD.Token.dwToken = 0U;
            USBHS_PDD_PrimeEndpoint(USBHS_BASE_PTR, EpDataPtr->EpMask);
          }
        }
      }
      Res = ERR_OK;
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return(Res);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueFlush (component USB_LDD)
**
**     Description :
**         Cancels all pending transfers for given endpoint and 
**         initialzes queue head.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceQueueFlush(LDD_TDeviceData *DeviceDataPtr, uint32_t EpIdx)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TQH                     *EpQHPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TTD                     *TDPtr;

  EpDataPtr = &DevDataPtr->EpData[EpIdx];                  /* Get address of the Ep data */
  if (EpDataPtr->EpState > USB_LDD_EP_NOT_CONFIGURED) {
    /* Flush endpoint queue */
    EpQHPtr     = &DevDataPtr->EpQH[EpIdx];                /* Get address of the Ep queue head */
    do {
      USBHS_PDD_FlushEndpoint(USBHS_BASE_PTR, EpDataPtr->EpMask);
      while (USBHS_PDD_GetFlushEndpointPendingFlag(USBHS_BASE_PTR, EpDataPtr->EpMask)) {} /* Wait for flush done */
    } while (USBHS_PDD_GetEndpointStatusFlag(USBHS_BASE_PTR, EpDataPtr->EpMask));
    USBHS_PDD_ClearEndpointCompleteFlag(USBHS_BASE_PTR, EpDataPtr->EpMask);
    /* Initilaze queue head */
    EpQHPtr->TD.NextTDPtr     = (USB_LDD_TTD*)1U;
    EpQHPtr->TD.Token.dwToken = 0x00U;
    /* For each transfer descriptor in the queue update transfer status and call user provided callback */
    TDPtr = EpQHPtr->TDQueuePtr;
    do {
      USB_LDD_DeviceCompleteTD(DevDataPtr, TDPtr);
      TDPtr = (USB_LDD_TTD *)((uint32_t)TDPtr->NextTDPtr & 0xFFFFFFFE); /* Get next TD */
    } while (TDPtr != EpQHPtr->TDQueueTailPtr);
    EpDataPtr->EpState = USB_LDD_EP_IDLE;
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueComplete (component USB_LDD)
**
**     Description :
**         Completes transfers for given endpoint.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceQueueComplete(USB_LDD_TDeviceData *DevDataPtr, uint32_t EpIdx)
{
  USB_LDD_TQH                     *EpQHPtr;
  USB_LDD_TTD                     *TDPtr;

    /* For each transfer descriptor in the queue update transfer status and call user provided callback */
    EpQHPtr = &DevDataPtr->EpQH[EpIdx];                    /* Get address of the Ep queue head */
    TDPtr = EpQHPtr->TDQueueHeadPtr;
    do {
      if ((TDPtr->Token.dwToken & (uint32_t)USB_LDD_TD_ACTIVE_MASK) != 0x00U) {
        break;
      }
      USB_LDD_DeviceCompleteTD(DevDataPtr, TDPtr);
      TDPtr = (USB_LDD_TTD *)((uint32_t)TDPtr->NextTDPtr & 0xFFFFFFFE); /* Get next TD */
    } while (TDPtr != EpQHPtr->TDQueueTailPtr);
    EpQHPtr->TDQueueHeadPtr = TDPtr;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDisableAllEps (component USB_LDD)
**
**     Description :
**         Initializes internal data structure and disables all endpoints.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceDisableAllEps(USB_LDD_TDeviceData *DevDataPtr)
{
  uint32_t                         x;

  /* Discard all pending transfers */
  for (x = 0x00U; x <= MAX_EP_IDX; x++) {                  /* Discard all pending transfers */
    (void)USB_LDD_DeviceQueueFlush(DevDataPtr, x);
  }
  /* Disable all endpoints */
  USBHS_PDD_WriteEp0CtrlReg(USBHS_BASE_PTR, 0x00);
  USBHS_PDD_WriteEp1CtrlReg(USBHS_BASE_PTR, 0x00);
  USBHS_PDD_WriteEp2CtrlReg(USBHS_BASE_PTR, 0x00);
  USBHS_PDD_WriteEp3CtrlReg(USBHS_BASE_PTR, 0x00);
  /* Sets endpoint data variables and endpoint queue heads to the initialization values */
  DevDataPtr->EpData[0x00u].EpState        = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x01u].EpState        = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x02u].EpState        = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x03u].EpState        = USB_LDD_EP_NOT_CONFIGURED;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceHandleEndpointUsbStatus (component USB_LDD)
**
**     Description :
**         See description of the GetUsbStatus() and SetUsbStatus() 
**         method.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceHandleEndpointUsbStatus(USB_LDD_TDeviceData *DevDataPtr, uint16_t Id, uint16_t *CmdStatusPtr)
{
  USB_LDD_TEpData                 *EpDataPtr;
  uint8_t                          EpNum = (uint8_t)(Id & (uint32_t)0x0FU);
  uint8_t                          EpDir = (uint8_t)(Id & (uint32_t)0x80U);
  LDD_TError                       Res = ERR_OK;

  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    return Res;
  }
  if ((Id & ~(uint32_t)LDD_USB_ID_EP_MASK) == 0x00U) {     /* EP address valid? */
    EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
    if (EpDataPtr->TransferType != LDD_USB_CONTROL) {      /* Control EP? */
      if (EpDir != LDD_USB_DIR_OUT) {                      /* No, update EpDataPtr for IN directin endpoint */
        EpDataPtr++;
      }
    }
    if ((uint32_t)EpDataPtr > (uint32_t)&(DevDataPtr->EpData[MAX_EP_IDX + 0x01u])) { /* Check address of EPx data structure */
      Res = ERR_PARAM_ADDRESS;
    }
    if (EpDataPtr->EpState <= USB_LDD_EP_NOT_CONFIGURED) { /* Is EP configured? */
      Res = ERR_PARAM_ADDRESS;                             /* No, =invalid EP */
    }
    if (EpDataPtr->TransferType == LDD_USB_ISOCHRONOUS) {  /* Isochronous EP? */
      Res = ERR_FAILED;                                    /* Isochronous EP has no HALT feature */
    }
    if (Res == ERR_OK) {
      switch (*CmdStatusPtr) {
        case LDD_USB_CMD_CLR_EP_HALT_FATURE:
          USB_LDD_DeviceUnstallEndpoint((LDD_TDeviceData*)DevDataPtr, EpNum, EpDir);
          break;
        case LDD_USB_CMD_SET_EP_HALT_FATURE:
          USB_LDD_DeviceStallEndpoint((LDD_TDeviceData*)DevDataPtr, EpNum, EpDir);
          break;
        case LDD_USB_CMD_GET_EP_STATUS:
          if (((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) != 0x00U) { /* Is EP stalled? */
            *CmdStatusPtr = LDD_USB_CMD_EP_STATUS_HALT_MASK; /* Yes, set halt feature in the returned value */
          } else {
            *CmdStatusPtr = 0x00U;                         /* Yes, clear halt feature in the returned value */
          }
          break;
        default:
          Res =  ERR_PARAM_COMMAND;                        /* Unsupported command */
          break;
      }
    }
  } else {
    Res = ERR_PARAM_ADDRESS;                               /* Bad EP address */
  }
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Init (component USB_LDD)
*/
/*!
**     @brief
**         Initializes USB device. Allocates memory for the device data
**         structure, interrupts, pins, etc. This method doesn't enable
**         device pull-up. Use Enable() method to enable device pull-up.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the dynamically allocated private
**                           structure or NULL if there was an error.
*/
/* ===================================================================*/
LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr;

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(USB_LDD_TDeviceData));
  DevDataPtr->UserDeviceDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_USBHS__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Interrupt vector(s) priority setting */
  /* NVICIP96: PRI96=0 */
  NVICIP96 = NVIC_IP_PRI96(0x00);
  /* NVICISER3: SETENA|=1 */
  NVICISER3 |= NVIC_ISER_SETENA(0x01);
  /* Pin routing */
  /* PORTA_PCR10: ISF=0,MUX=2 */
  PORTA_PCR10 = (uint32_t)((PORTA_PCR10 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* ADC3_SE4a/PTA10/ULPI_DATA0/FTM2_CH0/MII0_RXD2/FTM2_QD_PHA/TRACE_D0 */
  /* PORTA_PCR11: ISF=0,MUX=2 */
  PORTA_PCR11 = (uint32_t)((PORTA_PCR11 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* ADC3_SE15/PTA11/ULPI_DATA1/FTM2_CH1/MII0_RXCLK/FTM2_QD_PHB */
  /* PORTA_PCR24: ISF=0,MUX=2 */
  PORTA_PCR24 = (uint32_t)((PORTA_PCR24 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* CMP3_IN4/PTA24/ULPI_DATA2/MII0_TXD2/FBa_A29 */
  /* PORTA_PCR25: ISF=0,MUX=2 */
  PORTA_PCR25 = (uint32_t)((PORTA_PCR25 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* CMP3_IN5/PTA25/ULPI_DATA3/MII0_TXCLK/FBa_A28 */
  /* PORTA_PCR26: ISF=0,MUX=2 */
  PORTA_PCR26 = (uint32_t)((PORTA_PCR26 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* ADC2_SE15/PTA26/ULPI_DATA4/MII0_TXD3/FBa_A27 */
  /* PORTA_PCR27: ISF=0,MUX=2 */
  PORTA_PCR27 = (uint32_t)((PORTA_PCR27 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* ADC2_SE14/PTA27/ULPI_DATA5/MII0_CRS/FBa_A26 */
  /* PORTA_PCR28: ISF=0,MUX=2 */
  PORTA_PCR28 = (uint32_t)((PORTA_PCR28 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* ADC2_SE13/PTA28/ULPI_DATA6/MII0_TXER/FBa_A25 */
  /* PORTA_PCR29: ISF=0,MUX=2 */
  PORTA_PCR29 = (uint32_t)((PORTA_PCR29 & (uint32_t)~(uint32_t)(
                 PORT_PCR_ISF_MASK |
                 PORT_PCR_MUX(0x05)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x02)
                ));/* ADC2_SE12/PTA29/ULPI_DATA7/MII0_COL/FBa_A24 */
  /* PORTA_PCR7: ISF=0,MUX=2 */
  PORTA_PCR7 = (uint32_t)((PORTA_PCR7 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x05)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x02)
               ));/* ADC0_SE10/PTA7/ULPI_DIR/FTM0_CH4/I2S1_RX_BCLK/TRACE_D3 */
  /* PORTA_PCR8: ISF=0,MUX=2 */
  PORTA_PCR8 = (uint32_t)((PORTA_PCR8 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x05)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x02)
               ));/* ADC0_SE11/PTA8/ULPI_NXT/FTM1_CH0/I2S1_RX_FS/FTM1_QD_PHA/TRACE_D2 */
  /* PORTA_PCR9: ISF=0,MUX=2 */
  PORTA_PCR9 = (uint32_t)((PORTA_PCR9 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x05)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x02)
               ));/* ADC3_SE5a/PTA9/ULPI_STP/FTM1_CH1/MII0_RXD3/FTM1_QD_PHB/TRACE_D1 */
  /* PORTA_PCR6: ISF=0,MUX=2 */
  PORTA_PCR6 = (uint32_t)((PORTA_PCR6 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x05)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x02)
               ));/* ADC3_SE6a/PTA6/ULPI_CLK/FTM0_CH3/I2S1_RXD0/CLKOUTb/TRACE_CLKOUT */
  /* Clock setting */
  /* Input clock source:      External clock source connected to the ADC3_SE6a/PTA6/ULPI_CLK/FTM0_CH3/I2S1_RXD0/CLKOUTb/TRACE_CLKOUT pin */
  /* Input clock frequency:   Must be 60 MHz */
  /* Module clock frequency:  60 MHz */
  /* SIM_MCR: ULPICLKOBE=0 */
  SIM_MCR &= (uint32_t)~(uint32_t)(SIM_MCR_ULPICLKOBE_MASK); /* Disconnect internal generated ULPI clock from pin */
  /* Enable clock gate */
  /* SIM_SCGC6: USBHS=1 */
  SIM_SCGC6 |= SIM_SCGC6_USBHS_MASK;
  /* Initialize device data structure */
  DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;
  DevDataPtr->EnUser = FALSE;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID,DevDataPtr);
  return (LDD_TDeviceData*)(DevDataPtr);                    /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Enable (component USB_LDD)
*/
/*!
**     @brief
**         Enables the USB device (PHY, SIE). Enables device's DP(DM)
**         pull-up.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - 
*/
/* ===================================================================*/
LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {
    DevDataPtr->EnUser = TRUE;
    USB_LDD_UsbLock(DevDataPtr);
    /* Reset module */
    USBHS_PDD_ResetController(USBHS_BASE_PTR);
    /* EP 0 OUT (Rx) */
    DevDataPtr->EpData[0x00u].EpCtrlRegAddr  = &((uint16 *)(void *)USBHS_PDD_GetEp0CtrlRegAddr(USBHS_BASE_PTR))[0U];
    DevDataPtr->EpData[0x00u].EpMask         = 0x01U;
    DevDataPtr->EpQH[0x00u].TDQueuePtr       = &DevDataPtr->EP_0_OUT_dTD_Queue[0x00];
    /* EP 0 IN (Tx) */
    DevDataPtr->EpData[0x01u].EpCtrlRegAddr  = &((uint16 *)(void *)USBHS_PDD_GetEp0CtrlRegAddr(USBHS_BASE_PTR))[1U];
    DevDataPtr->EpData[0x01u].EpMask         = 0x00010000U;
    DevDataPtr->EpQH[0x01u].TDQueuePtr       = &DevDataPtr->EP_0_IN_dTD_Queue[0x00];
    /* EP 1 OUT (Rx) */
    DevDataPtr->EpData[0x02u].EpCtrlRegAddr  = &((uint16 *)(void *)USBHS_PDD_GetEp0CtrlRegAddr(USBHS_BASE_PTR))[2U];
    DevDataPtr->EpData[0x02u].EpMask         = 0x02U;
    DevDataPtr->EpQH[0x02u].TDQueuePtr       = &DevDataPtr->EP_1_OUT_dTD_Queue[0x00];
    /* EP 1 IN (Tx) */
    DevDataPtr->EpData[0x03u].EpCtrlRegAddr  = &((uint16 *)(void *)USBHS_PDD_GetEp0CtrlRegAddr(USBHS_BASE_PTR))[3U];
    DevDataPtr->EpData[0x03u].EpMask         = 0x00020000U;
    DevDataPtr->EpQH[0x03u].TDQueuePtr       = &DevDataPtr->EP_1_IN_dTD_Queue[0x00];
    /* Wait for reset done */
    while (USBHS_PDD_GetControllerResetPendingFlag(USBHS_BASE_PTR)) {}
    USBHS_BURSTSIZE = USBHS_BURSTSIZE_TXPBURST(0x01) |
                      USBHS_BURSTSIZE_RXPBURST(0x05);
    USBHS_USBCMD = USBHS_USBCMD_ITC(0x00) |
                   USBHS_USBCMD_ASP(0x00) |
                   USBHS_USBCMD_FS(0x00);
    USB_LDD_DeviceDisableAllEps(DevDataPtr);
    /* Initialize device queue head (dQH) pointer */
    USBHS_EPLISTADDR = (uint32_t)DevDataPtr;
    /* USBHS_USBMODE: ??=0,??=0,??=0,SDIS=0,SLOM=1,ES=0,CM=2 */
    USBHS_USBMODE = (uint32_t)((USBHS_USBMODE & (uint32_t)~(uint32_t)(
                     USBHS_USBMODE_SDIS_MASK |
                     USBHS_USBMODE_ES_MASK |
                     USBHS_USBMODE_CM(0x01) |
                     0xE0U
                    )) | (uint32_t)(
                     USBHS_USBMODE_SLOM_MASK |
                     USBHS_USBMODE_CM(0x02)
                    ));
    USBHS_PDD_SetUsbInterruptMask(USBHS_BASE_PTR, USBHS_PDD_SLEEP_INT | USBHS_PDD_BUS_RESET_INT | USBHS_PDD_PORT_CHANGE_DETECT_INT | USBHS_PDD_USB_ERROR_INT | USBHS_PDD_USB_TRANSFER_DONE); /* Enable reset and suspend interrupts */
    USBHS_PDD_Disable1msInterrupt(USBHS_BASE_PTR);          /* Disable "1ms" interrupt */
    if (USBHS_PDD_GetBSessionValidSignalState(USBHS_BASE_PTR)) { /* Is VBUS on? */
      DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_ON;     /* VBUS is on, remember new state */
    } else {
      DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_OFF;    /* VBUS is off, remember new state */
    }
    USBHS_PDD_StartController(USBHS_BASE_PTR);              /* Enable device mode */
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Disable (component USB_LDD)
*/
/*!
**     @brief
**         Disabled device's DP(DM) pull-up. Disables PHY, etc.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - 
*/
/* ===================================================================*/
LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (DevDataPtr->EnUser) {
    DevDataPtr->EnUser = FALSE;
    USB_LDD_UsbLock(DevDataPtr);
    DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;     /* Remember new device state */
    USBHS_PDD_DisableAllUsbInterrupt(USBHS_BASE_PTR);      /* Enable reset and suspend interrupts */
    USBHS_PDD_Disable1msInterrupt(USBHS_BASE_PTR);         /* Disable "1ms" interrupt */
    USBHS_PDD_StopController(USBHS_BASE_PTR);              /* Stop controller */
    USBHS_PDD_SuspendPhy(USBHS_BASE_PTR);                  /* Disable transceiver */
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceGetUsbStatus (component USB_LDD)
*/
/*!
**     @brief
**         Returns the status of the object (e.g. endpoint). This
**         method is intended to be used in the standard USB
**         'GetStatus' request handler.
**         The object is described by the command (CmdStatusPtr
**         parameter) and by the id (Id parameter). 
**         The supported commands are:
**         [1) LDD_USB_CMD_GET_EP_STATUS] - Fills the memory addressed
**         by the CmdStatusPtr parameter by the current endpoint XXX
**         status (where XXX = Id parameter value) .
**         Format of the returned status is defined in the USB
**         specification 2.0, figure 9.6.
**         The LDD_USB_CMD_EP_STATUS_HALT_MASK constant can be used to
**         get endpoint status from the returned value.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Id              - Id. (E.g endpoint address for endpoint
**                           status, ...)
**                           The Id parameter value has the same format
**                           as wIndex parameter in the setup data
**                           packet - see USB specification.
**     @param
**         CmdStatusPtr    - Pointer to the uint16_t
**                           in/out variable. This variable must
**                           contains requested command before the
**                           method is called and contains requested
**                           status after the method returns.
**                           The supported command are:
**                           LDD_USB_CMD_GET_EP_STATUS
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_PARAM_ADDRESS - No such object (e.g.
**                           endpoint doesn't exists or is not enabled
**                           by the host). Note: The 'Id' parameter
**                           check is always enabled in order to
**                           simplify implementation of the standard USB
**                           GetStatus request handler.
**                           ERR_FAILED - Command not supported for
**                           current object setting (e.g. STALL feature
**                           is not supported for isochronous endpoints).
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command cannot be accomplished
**                           in XXX <device state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceGetUsbStatus(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t *CmdStatusPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData *)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (*CmdStatusPtr == LDD_USB_CMD_GET_EP_STATUS) {         /* EP command? */
    Res = USB_LDD_DeviceHandleEndpointUsbStatus(DevDataPtr, Id, CmdStatusPtr);
  } else {
    Res = ERR_PARAM_COMMAND;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSetUsbStatus (component USB_LDD)
*/
/*!
**     @brief
**         Sets the status(feature) of the object (e.g. endpoint). This
**         method is intended to be used in the standard USB
**         ClearFeature/SetFeature request handler.
**         The object is described by the command (Cmd parameter) and
**         by the id (Id parameter). 
**         The supported commands are:
**         [LDD_USB_CMD_SET_EP_HALT_FATURE] - Sets HALT feature for
**         endpoint XXX (where XXX = Id parameter value).
**         [LDD_USB_CMD_CLR_EP_HALT_FATURE] - Clears HALT feature for
**         endpoint XXX (where XXX = Id parameter value).
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Id              - Id. (E.g endpoint address for endpoint
**                           status, ...)
**                           The Id parameter value has the same format
**                           as wIndex parameter in the setup data
**                           packet - see USB specification.
**     @param
**         Cmd             - Command. Supported commands are:
**                           LDD_USB_CMD_SET_EP_HALT_FATURE
**                           LDD_USB_CMD_CLR_EP_HALT_FATURE
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_PARAM_ADDRESS - No such object (e.g.
**                           endpoint doesn't exists or is not enabled
**                           by the host). Note: The 'Id' parameter
**                           check is always enabled in order to
**                           simplify implementation of the standard USB
**                           GetStatus request handler.
**                           ERR_FAILED - Command not supported for
**                           current object setting (e.g. STALL feature
**                           is not supported for isochronous endpoints).
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command cannot be accomplished
**                           in XXX <device state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceSetUsbStatus(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t Cmd)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData *)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  switch (Cmd) {
    case LDD_USB_CMD_CLR_EP_HALT_FATURE:
    case LDD_USB_CMD_SET_EP_HALT_FATURE:
       Res = USB_LDD_DeviceHandleEndpointUsbStatus(DevDataPtr, Id, &Cmd);
       break;
    default:
      Res = ERR_PARAM_COMMAND;
      break;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSetAddress (component USB_LDD)
*/
/*!
**     @brief
**         Sets new device address. Address must be in range 0-127 but
**         no check is performed.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Address         - New device address.
*/
/* ===================================================================*/
void USB_LDD_DeviceSetAddress(LDD_TDeviceData *DeviceDataPtr, uint8_t Address)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  USBHS_PDD_SetDeviceAddress(USBHS_BASE_PTR, Address);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceInitEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Initializes endpoint according to the values in the
**         <standard Endpoint descriptor> and in the flags parameter.
**         As soon as the ERR_OK is returned the endpoint can be used
**         to transmit data. To initialize endpoint 0 you can create
**         Endpoint descriptor for EP0 or you can use the <standard
**         Device descriptor>.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpDescriptorPtr - Pointer to
**                           standard Endpoint descriptor structure
**                           pointer. To initialize EP0 you can use
**                           pointer to the standard Device descriptor
**                           structure.
**     @param
**         Flags           - Additional EP properties. 
**                           For Bulk/Interrupt transfer types:
**                           0 = no ZLT,  1 = ZLT
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the HW.
**                           ERR_PARAM_TYPE - Requested transfer is not
**                           supported by the HW for given address and
**                           direction.
**                           ERR_PARAM_SIZE - Requested max. packet size
**                           is not supported by the HW.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - Device is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceInitEndpoint(LDD_TDeviceData *DeviceDataPtr, LDD_USB_TEpDescriptor *EpDescriptorPtr, uint8_t Flags)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res = ERR_OK;
  uint32_t                         EpIdx;
  LDD_USB_TTransferType            EpTransferType;
  uint16_t                         EpMaxPacketSize;
  uint32_t                         TDQueueSize;
  USB_LDD_TQH                     *EpQHPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TTD                     *TDPtr;
  uint32_t                         x,y = 2U;
  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  if (EpDescriptorPtr->bDescriptorType == LDD_USB_DT_DEVICE) {
    EpIdx           = 0U;
    EpTransferType  = LDD_USB_CONTROL;
    EpMaxPacketSize = ((LDD_USB_TDevDescriptor *)(void *)EpDescriptorPtr)->bMaxPacketSize0; /* Get max. packet size from Device descriptor */
  } else {
    EpIdx           = ((uint32_t)(EpDescriptorPtr->bEndpointAddress & (uint32_t)0x07)<< 1);
    if (EpDescriptorPtr->bEndpointAddress & 0x80U) {
      EpIdx++;
    }
    EpTransferType = (LDD_USB_TTransferType )((EpDescriptorPtr->bmAttributes) & 0x03U); /* Get transfer type from Ep descriptor */
    EpMaxPacketSize = EpDescriptorPtr->wMaxPacketSize;      /* Get max. packet size from Ep descriptor */
  }
  TDQueueSize  = ((uint32_t)Flags & 0x7FU);                 /* Get queue size */
  TDQueueSize |= 0x01U;                                     /* Queue size must be >= 1 */
  do {
    EpQHPtr   = &DevDataPtr->EpQH[EpIdx];                  /* Get address of the Ep queue head */
    EpDataPtr = &DevDataPtr->EpData[EpIdx];                /* Get address of the Ep data */
    TDPtr     = EpQHPtr->TDQueuePtr;                       /* Get address of the firts TD in the queue */
    if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX]) { /* Check address of EPx data structure */
      Res = ERR_PARAM_ADDRESS;
    }
    if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
      Res = ERR_PARAM_ADDRESS;
    }
    if (Res != ERR_OK) {
      break;
    }
    EpDataPtr->EpState          = USB_LDD_EP_IDLE;
    EpDataPtr->TransferType     = EpTransferType;
    EpDataPtr->MaxPacketSize    = EpMaxPacketSize;
    /* Prepare EP queue head */
    EpQHPtr->Capabilities.dwCapabilities = ((uint32_t)EpMaxPacketSize & (uint32_t)0x03FF) << 16; /* Remember max. packet size */
    EpQHPtr->TD.NextTDPtr                = (USB_LDD_TTD *)0x01U;
    EpQHPtr->TD.Token.dwToken            = 0x00U;
    EpQHPtr->TDQueueHeadPtr              = TDPtr;
    EpQHPtr->TDQueueTailPtr              = TDPtr;
    /* Prepare TDs queue */
    for (x = 0x00U; x < TDQueueSize; x++) {                /* For each TD in the queue do: */
      TDPtr->Token.dwToken = 0U;                           /* Set status to not active */
      TDPtr->NextTDPtr = (USB_LDD_TTD *)((uint32_t)(TDPtr + 0x01U) | 1U); /* Chain TDs, set T bit */
      TDPtr++;
    }
    (--TDPtr)->NextTDPtr = (USB_LDD_TTD *)((uint32_t)EpQHPtr->TDQueuePtr | 1U); /* LastTD.Next = FirstTD */
    /* Set transfer mode dependant values */
    if (EpTransferType == LDD_USB_CONTROL) {
      EpQHPtr->Capabilities.dwCapabilities |= 0x8000U;     /* IOS = true, ZLT = true */
      if (--y == 0U) {
        USB_LDD_EnableCtrlEp(EpDataPtr->EpCtrlRegAddr);
      }
    } else {
      if (EpTransferType == LDD_USB_ISOCHRONOUS) {
        /* Set MULT field in endpoint capatibilities */
        EpQHPtr->Capabilities.dwCapabilities |= (((uint32_t)EpMaxPacketSize & (uint32_t)0x0C00) << 19);
        if ((EpQHPtr->Capabilities.dwCapabilities & 0xC0000000U) == 0U) { /* MULT must be non-zero for ISO endpoints */
          EpQHPtr->Capabilities.dwCapabilities |= 0x40000000;
        }
      }
      if (!(Flags & 0x80U)) {
        EpQHPtr->Capabilities.dwCapabilities |= 0x20000000U; /* ZLT = false */
      }
      USB_LDD_EnableBulkIntIsoEp(EpDataPtr->EpCtrlRegAddr, EpTransferType);
      y = 0U;                                              /* Stop loop */
    }
    EpIdx     = EpIdx  ^ 0x01U;                            /* Set EpIdex to address Ep control register */
  } while (y != 0U);
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDeinitEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Deinitializes EP and disables it in the HW. For control EP
**         both directions are deinitialized. All pending transfers are
**         aborted and callback functions are called, if enabled.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the HW.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - Device is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceDeinitEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  uint32_t                         EpIdx;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpIdx = ((uint32_t)EpNum << 0x01u);
  if (EpDir != LDD_USB_DIR_OUT) {                          /* Get EpIdx */
    EpIdx++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpIdx > MAX_EP_IDX) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  EpDataPtr = &DevDataPtr->EpData[EpIdx];
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState > USB_LDD_EP_NOT_CONFIGURED) {
    if (EpDataPtr->TransferType == LDD_USB_CONTROL) {       /* Control EP? */
      USB_LDD_DisableCtrlEp(EpDataPtr->EpCtrlRegAddr);
      (EpDataPtr + 1)->EpState = USB_LDD_EP_NOT_CONFIGURED;
    } else {
      USB_LDD_DisableBulkIntIsoEp(EpDataPtr->EpCtrlRegAddr);
    }
    EpDataPtr->EpState = USB_LDD_EP_NOT_CONFIGURED;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceStallEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Sets STALL feature for endpoint.
**         Note: No parameters and endpoint state are checked. The
**         <DeviceSetUsbStatus()> method provides same functionality
**         with state and parameter checking.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
*/
/* ===================================================================*/
void USB_LDD_DeviceStallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
  if (EpDataPtr->TransferType == LDD_USB_CONTROL) {        /* Control EP? */
    USB_LDD_HwStallCtrlEp(EpDataPtr->EpCtrlRegAddr);
    ((EpDataPtr + 1)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr + 1)->EpState) | (uint32)USB_LDD_EP_STALLED));
  } else {
    if (EpDir != LDD_USB_DIR_OUT) {
      EpDataPtr++;
    }
    USB_LDD_HwStallBulkIntIsoEp(EpDataPtr->EpCtrlRegAddr);
  }
  ((EpDataPtr)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr)->EpState) | (uint32)USB_LDD_EP_STALLED));
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceUnstallEndpoint (component USB_LDD)
*/
/*!
**     @brief
**         Clears STALL feature for endpoint.
**         Note: No parameters and endpoint state are checked. The
**         <DeviceSetUsbStatus()> method provides same functionality
**         with state and parameter checking.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
*/
/* ===================================================================*/
void USB_LDD_DeviceUnstallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
  if (EpDataPtr->TransferType == LDD_USB_CONTROL) {        /* Control EP? */
    USB_LDD_HwUnstallCtrlEp(EpDataPtr->EpCtrlRegAddr);
    ((EpDataPtr + 1)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr + 1)->EpState) & ~(uint32)USB_LDD_EP_STALLED));
  } else {
    if (EpDir != LDD_USB_DIR_OUT) {
      EpDataPtr++;
    }
    USB_LDD_HwUnstallBulkIntIsoEp(EpDataPtr->EpCtrlRegAddr);
  }
  ((EpDataPtr)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr)->EpState) & ~(uint32)USB_LDD_EP_STALLED));
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceReadSetupData (component USB_LDD)
*/
/*!
**     @brief
**         Fills the given buffer with last received setup data packet
**         for given EP.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         SDPPtr          - Address of the buffer for setup data.
*/
/* ===================================================================*/
void USB_LDD_DeviceReadSetupData(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, LDD_USB_TSDP *SDPPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  uint32_t                         EpIdx = ((uint32_t)EpNum << 0x01u) & (uint32_t)0xFFU ;

  USB_LDD_UsbLock(DevDataPtr);
  do {
    USBHS_PDD_SetSetupTripwire(USBHS_BASE_PTR);
    *SDPPtr = *(LDD_USB_TSDP *)(&DevDataPtr->EpQH[EpIdx].SDP);
  } while (USBHS_PDD_GetSetupTripwire(USBHS_BASE_PTR) == 0U);
  USBHS_PDD_ClrSetupTripwire(USBHS_BASE_PTR);
  EpDataPtr = &DevDataPtr->EpData[EpIdx];
  EpDataPtr->TT.Ctrl.ReqDataSize = SDPPtr->wLength;        /* Remember requested data size */
  (EpDataPtr + 1U)->TT.Ctrl.ReqDataSize = SDPPtr->wLength; /* Remember requested data size */
  if (SDPPtr->wLength == 0x00U) {
    /* No-data control transfer */
    EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_NO_DATA;       /* Rx - No data should be received */
    (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_NO_DATA_HSK; /* Tx - Handshake should be sent */
  } else if ((SDPPtr->bmRequestType & LDD_USB_DIR_IN) != 0x00U) {
    /* Control read */
    EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_READ_HSK;      /* Rx - Handshake should be received */
    (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_READ_DATA; /* Tx - Data should be sent */
  } else {
    /* Control write */
    EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_WRITE_DATA;    /* Rx - Data should be received */
    (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_WRITE_HSK; /* Tx - Handshake should be sent */
  }
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSendData (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares data to be sent to the HOST (transfer
**         request). The transfer request is queued into the internal
**         queue of requests for given endpoint. Some devices have HW
**         queues. On other devices the queue can be emulated by the SW
**         or no queue is implemented (property Max. queue size = 1 and
**         cannot be modified). Size of queue can be defined for each
**         endpoint at the design time. As soon as the host sends IN
**         token data from the request on the queue head are sent to
**         the HOST. This process is repeated until all data are
**         transferred or transfer is cancelled. If the transfer is
**         done the request is removed from the queue and next request
**         becomes ready for transmission, if queue not empty.
**         Each transfer is described by the <transfer descriptor (TD)>
**         structure.
**         The first item of the TD is the <Head> structure. The Head
**         structure item is required and contains these items:
**         _/[EpNum]/_ - endpoint number.
**         _/[BufferPtr]/_ - buffer address.
**         _/[BufferSize]/_ - buffer size.
**         _/[Flags]/_ - flags:
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_ZLT/_ - this flag can be used
**         to force zero-length termination(ZLT) of the transfer.
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM/_ - see below.
**         The following items of the TD are optional:
**         _/[TransmittedDataSize]/_ - this item is set by the driver
**         and contains actual number of transmitted data.
**         _/[CallbackFnPtr]/_ - pointer to the callback function
**         called (if not NULL) after the transfer is done.
**         _/[ParamPtr]/_ - parameter passed to the callback function.
**         The optional items can be used to track the status of the
**         transfer request and are used(accessed) by the driver only
**         if <LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM> flag is set to
**         '1' in the Head.Flags item. In this case the TD must be
**         accessible from the ISR and may be freed only if the
**         transfer is done (TransfereState item must be lower then
**         LDD_USB_TRANSFER_QUEUED). Pending transfer requests can be
**         cancelled by the <DeviceCancelTransfer()> method.
**         Transfer is done if all data are sent. If data size = max.
**         packet size and ZLT is enabled the zero length packet is
**         send as the last packet of the transfer.
**         [Note:]For control transfer the transmitted data size
**         truncated (if necessary) by the driver to the size requested
**         by the host (wLength item of setup data packet) and the ZLT
**         is added if needed. Note: On some MCUs (e.g. Kinetis) must
**         be the address of the data buffer 4 bytes aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to the <transfer descriptor (TD)>
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_QFULL - Endpoint transfer queue is full.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceSendData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr)
{
  return(USB_LDD_DeviceQueueInsert((USB_LDD_TDeviceData*)DeviceDataPtr, TransferDescriptorPtr, LDD_USB_DIR_IN));
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceRecvData (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares buffer for data sent by the HOST
**         (transfer request). The transfer request is queued into the
**         internal queue of requests for given endpoint. Some devices
**         have HW queues. On other devices the queue can be emulated
**         by the SW or no queue is implemented (property Max. queue
**         size = 1 and cannot be modified). Size of queue can be
**         defined for each endpoint at the design time. Data from the
**         HOST are stored into the provided buffer. If the transfer is
**         done the request is removed from the queue and next request
**         becomes ready for transmission, if queue not empty.
**         Each transfer is described by the <transfer descriptor (TD)>
**         structure.
**         The first item of the TD is the <Head> structure. The Head
**         structure item is required and contains these items:
**         _/[EpNum]/_ - endpoint number.
**         _/[BufferPtr]/_ - buffer address.
**         _/[BufferSize]/_ - buffer size.
**         _/[Flags]/_ - flags:
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM/_ - see below.
**         The following items of the TD are optional:
**         _/[TransmittedDataSize]/_ - this item is set by the driver
**         and contains actual number of transmitted data.
**         _/[CallbackFnPtr]/_ - pointer to the callback function
**         called (if not NULL) after the transfer is done.
**         _/[ParamPtr]/_ - parameter passed to the callback function.
**         The optional items can be used to track the status of the
**         transfer request and are used(accessed) by the driver only
**         if <LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM> flag is set to
**         '1' in the Head.Flags item. In this case the TD must be
**         accessible from the ISR and may be freed only if the
**         transfer is done (TransfereState item must be lower then
**         LDD_USB_TRANSFER_QUEUED). Pending transfer requests can be
**         cancelled by the <DeviceCancelTransfer()> method.
**         Transfer is done if all requested data are received or
**         short(zero length) packet is received. Note: On some MCUs (e.
**         g. Kinetis) must be the address of the data buffer 4 bytes
**         aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to the <transfer descriptor (TD)>
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_QFULL - Endpoint transfer queue is full.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceRecvData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr)
{
  return(USB_LDD_DeviceQueueInsert((USB_LDD_TDeviceData*)DeviceDataPtr, TransferDescriptorPtr, LDD_USB_DIR_OUT));
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceCancelTransfer (component USB_LDD)
*/
/*!
**     @brief
**         Cancels all pending transfers in the given EP queue.
**         Transfer status is updated and callback function is called
**         for each cancelled transfer request if enabled in the
**         <SendData> or <RecvData> methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         EpNum           - Endpoint number.
**     @param
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     @return
**                         - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
*/
/* ===================================================================*/
LDD_TError USB_LDD_DeviceCancelTransfer(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  uint32_t                         EpIdx;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  EpIdx = ((uint32_t)EpNum << 0x01u);
  if (EpDir != LDD_USB_DIR_OUT) {                          /* Get EpIdx */
    EpIdx++;
  }
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpIdx = ((uint32_t)EpNum << 0x01u);
  if (EpDir != LDD_USB_DIR_OUT) {                          /* Get EpIdx */
    EpIdx++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpIdx > MAX_EP_IDX) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  EpDataPtr = &DevDataPtr->EpData[EpIdx];
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  Res = USB_LDD_DeviceQueueFlush(DevDataPtr, EpIdx);
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceIsr (component USB_LDD)
**
**     Description :
**         Device mode interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t InSignalsState)
{
  uint32_t                         IntStatus;
  uint32_t                         EpStatus;

  (void)InSignalsState;                                    /* Parameter is not used, suppress unused argument warning */
  if (DevDataPtr->DeviceState >= LDD_USB_DEVICE_VBUS_OFF) { /* Device enabled and VBUS = ON? */
    IntStatus = USBHS_PDD_GetUsbInterruptFlags(USBHS_BASE_PTR);
    IntStatus &= USBHS_PDD_GetUsbInterruptMask(USBHS_BASE_PTR);
    if (IntStatus != 0U) {
      if ((IntStatus & (USBHS_PDD_USB_TRANSFER_DONE | USBHS_PDD_USB_ERROR_INT)) != 0x00U) { /* USB interrupt? */
        /* Transfer complete interrupt handler */
        USBHS_PDD_ClearUsbInterruptFlags(USBHS_BASE_PTR, USBHS_PDD_USB_TRANSFER_DONE | USBHS_PDD_USB_ERROR_INT);
        EpStatus = USBHS_PDD_GetAllEndpointCompleteFlags(USBHS_BASE_PTR); /* Get transmitt complete received flags */
        USBHS_PDD_ClearEndpointCompleteFlag(USBHS_BASE_PTR, EpStatus); /* Clear setup packet received flags */
        if (EpStatus & 0x01U) {
          USB_LDD_DeviceQueueComplete(DevDataPtr, 0x00U); /* EP0_OUT transfer done */
        }
        if (EpStatus & 0x00010000U) {
          USB_LDD_DeviceQueueComplete(DevDataPtr, 0x01U); /* EP0_IN transfer done */
        }
        if (EpStatus & 0x02U) {
          USB_LDD_DeviceQueueComplete(DevDataPtr, 0x02U); /* EP1_OUT transfer done */
        }
        if (EpStatus & 0x00020000U) {
          USB_LDD_DeviceQueueComplete(DevDataPtr, 0x03U); /* EP1_IN transfer done */
        }
        /* Setup packet received  interrupt handler */
        EpStatus = USBHS_PDD_GetAllEndpointSetupFlag(USBHS_BASE_PTR); /* Get setup packet received flags */
        USBHS_PDD_ClearEndpointSetupFlag(USBHS_BASE_PTR, EpStatus); /* Clear setup packet received flags */
        if (EpStatus != 0U) {                               /* Setup packet received? */
          if (EpStatus & 0x01U) {
            (void)USB_LDD_DeviceQueueFlush(DevDataPtr, 0x00U);
            (void)USB_LDD_DeviceQueueFlush(DevDataPtr, 0x01U);
            USB_LDD_OnDeviceSetupPacket(DevDataPtr->UserDeviceDataPtr,  (uint8_t)0U);
          }
        }
      }
      if ((IntStatus & USBHS_PDD_BUS_RESET_INT) != 0x00U) { /* USB Reset Signal detected? */
        /* Reset signal detected interrupt handler */
        USBHS_PDD_ClearBusResetInterruptFlag(USBHS_BASE_PTR); /* Clear "reset" interrupt flag */
        USBHS_PDD_ClearAllEndpointSetupFlags(USBHS_BASE_PTR); /* Clear all setup token flags */
        USBHS_PDD_ClearAllEndpointCompleteFlags(USBHS_BASE_PTR); /* Clear all complete token flags */
        while(USBHS_PDD_GetAllPrimeEndpointPendingFlags(USBHS_BASE_PTR)) {} /* Wait untill all PRIME bits are 0 */
        if (USBHS_PDD_GetBusResetPendingFlag(USBHS_BASE_PTR)) {
          /* Reset signal is still active = all transfers has been successfully discarded */
          USB_LDD_DeviceDisableAllEps(DevDataPtr);
        } else {
          /* Reset signal is NOT active -> a transfer not discarded before reset is done can cause enumeration problem */
        }
      } else {
        if ((IntStatus & USBHS_PDD_PORT_CHANGE_DETECT_INT) != 0x00U) { /* Port change detected? */
          /* Port change detected interrupt handler */
          USBHS_PDD_ClearPortChangeDetectInterruptFlag(USBHS_BASE_PTR); /* Clear interrupt flag */
          if (DevDataPtr->DeviceState > LDD_USB_DEVICE_ENABLED) { /* Exit from suspend state */
            DevDataPtr->DeviceState = LDD_USB_DEVICE_ENABLED; /* Remember new device state */
          } else {
            DevDataPtr->DeviceState = LDD_USB_DEVICE_ENABLED; /* Remember new device state */
            USB_LDD_OnDeviceSpeedDetect(DevDataPtr->UserDeviceDataPtr, (LDD_USB_TBusSpeed)USBHS_PDD_GetBusSpeed(USBHS_BASE_PTR));
          }
        } else if ((IntStatus & USBHS_PDD_SLEEP_INT) != 0x00U) { /* Suspend detected (Idle more then 3 ms)? */
          /* Suspend detected interrupt handler */
          USBHS_PDD_ClearSleepInterruptFlag(USBHS_BASE_PTR); /* Clear "suspend" interrupt flag */
          DevDataPtr->LastDeviceState = DevDataPtr->DeviceState; /* Remember current device state */
          DevDataPtr->DeviceState = LDD_USB_DEVICE_SUSPENDED; /* Set new device state state */
        } else {
          ;
        }
      }
    } else {
      ;
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_USB_Interrupt (component USB_LDD)
**
**     Description :
**         USB interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(USB_LDD_USB_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  USB_LDD_TDeviceDataPtr DevDataPtr = INT_USBHS__DEFAULT_RTOS_ISRPARAM;
  uint32_t NewInSignalState = 0U;
  
  DevDataPtr->ISR = TRUE;
  
  NewInSignalState = DevDataPtr->InSignalsState;           /* Get current signal state */
  USB_LDD_DeviceIsr(DevDataPtr, NewInSignalState);         /* Call device interrupt handler */
  
  DevDataPtr->ISR = FALSE;
}


/*lint -restore Enable MISRA rule (11.4) checking. */
/* END USB_LDD. */

#ifdef __cplusplus
}  /* extern "C" */
#endif 

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.4 [05.11]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
